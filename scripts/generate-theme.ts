import { execSync } from 'child_process';
import chroma from 'chroma-js';
import fs from 'fs';
import path from 'path';
import { COLORS } from '../theme/base';

function parseOKLCH(oklchStr: string): {
  l: number;
  c: number;
  h: number;
  a?: string;
} {
  const match = oklchStr.match(/oklch\(([^)]+)\)/);
  if (!match) throw new Error('Invalid OKLCH: ' + oklchStr);
  const parts = match[1].split('/').map((s) => s.trim());
  const [l, c, h] = parts[0].split(/\s+/).map(Number);
  const a = parts[1] ? parts[1] : undefined;
  return { l, c, h, a };
}

function oklchToHSLStr(oklchStr: string): string {
  const { l, c, h, a } = parseOKLCH(oklchStr);
  const hsl = chroma.oklch(l, c, h).hsl();
  let hVal = Math.round(hsl[0]);
  let sVal = Math.round(hsl[1] * 100);
  let lVal = Math.round(hsl[2] * 100);
  if (isNaN(hVal)) hVal = 0;
  if (isNaN(sVal)) sVal = 0;
  if (isNaN(lVal)) lVal = 0;

  if (sVal === 0 || lVal === 0 || lVal === 100) {
    hVal = 0;
    sVal = 0;
  }

  if (a) return `${hVal} ${sVal}% ${lVal}% / ${a}`;
  return `${hVal} ${sVal}% ${lVal}%`;
}

function oklchToRGBStr(oklchStr: string): string {
  const { l, c, h, a } = parseOKLCH(oklchStr);
  const rgb = chroma.oklch(l, c, h).rgb();
  const r = Math.round(rgb[0]);
  const g = Math.round(rgb[1]);
  const b = Math.round(rgb[2]);
  if (a) return `rgba(${r}, ${g}, ${b}, ${a})`;
  return `rgb(${r}, ${g}, ${b})`;
}

function genCSSVars(theme: any) {
  let css = '';

  for (const [key, value] of Object.entries(theme)) {
    const varName = `--${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
    css += `${varName}:${oklchToHSLStr(value as string)};`;
  }

  return css;
}

function generateGlobalCSS() {
  const lightVars = genCSSVars(COLORS.light.ui);
  const darkVars = genCSSVars(COLORS.dark.ui);
  return `/* generated by @/scripts/generate-theme.ts */\n\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base{\n:root{${lightVars}}\n\n@media (prefers-color-scheme: dark){:root{${darkVars}}}\n}`;
}

function generateNavigationTS() {
  const lightBg = oklchToRGBStr(COLORS.light.ui.background);
  const darkBg = oklchToRGBStr(COLORS.dark.ui.background);
  const lightBorder = oklchToRGBStr(COLORS.light.ui.border);
  const darkBorder = oklchToRGBStr(COLORS.dark.ui.border);
  return `// generated by @/scripts/generate-theme.ts\n\nimport { DarkTheme, DefaultTheme } from '@react-navigation/native';\n\nexport const NAVIGATION=Object.freeze({\nlight:{...DefaultTheme,colors:{...DefaultTheme.colors,background:'${lightBg}',card:'${lightBg}',border:'${lightBorder}'}},\ndark:{...DarkTheme,colors:{...DarkTheme.colors,background:'${darkBg}',card:'${darkBg}',border:'${darkBorder}'}}\n});`;
}

function generateSpectrumTS() {
  function getVariants(oklchStr: string) {
    const { l, c, h } = parseOKLCH(oklchStr);

    const variants = {
      lighter: `hsl(${oklchToHSLStr(`oklch(${Math.min(l + 0.075, 1)} ${c} ${h})`)})`,
      default: `hsl(${oklchToHSLStr(oklchStr)})`,
      darker: `hsl(${oklchToHSLStr(`oklch(${Math.max(l - 0.075, 0)} ${c} ${h})`)})`,
    };

    return variants;
  }

  const spectrum: any = { light: [], dark: [] };

  for (const mode of ['light', 'dark'] as const) {
    const modeColors = COLORS[mode] as typeof COLORS.light;

    for (const [key, value] of modeColors.spectrum.entries()) {
      spectrum[mode][key] = getVariants(value as string);
    }
  }

  return `// generated by @/scripts/generate-theme.ts\n\nexport const SPECTRUM=${JSON.stringify(spectrum)};\n\nexport type Color=keyof typeof SPECTRUM.light;`;
}

fs.mkdirSync(path.join(__dirname, '../theme'), { recursive: true });

fs.writeFileSync(
  path.join(__dirname, '../theme/global.css'),
  generateGlobalCSS()
);

fs.writeFileSync(
  path.join(__dirname, '../theme/navigation.ts'),
  generateNavigationTS()
);

fs.writeFileSync(
  path.join(__dirname, '../theme/spectrum.ts'),
  generateSpectrumTS()
);

execSync(
  'bunx prettier --write "theme/global.css" "theme/navigation.ts" "theme/spectrum.ts"',
  { stdio: 'inherit' }
);
